"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[4083],{48893:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>r,metadata:()=>o,toc:()=>c});var s=n(85893),i=n(3905);const r={sidebar_position:2,sidebar_label:"Tree",hide_title:!0},a=void 0,o={id:"metrics/behavior/flows/tree",title:"tree",description:"Flows Tree",source:"@site/docs/metrics/behavior/flows/tree.md",sourceDirName:"metrics/behavior/flows",slug:"/metrics/behavior/flows/tree",permalink:"/docs/metrics/behavior/flows/tree",draft:!1,unlisted:!1,editUrl:"https://github.com/botanalytics/docs/tree/master/docs/metrics/behavior/flows/tree.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2,sidebar_label:"Tree",hide_title:!0},sidebar:"tutorialSidebar",previous:{title:"Sankey",permalink:"/docs/metrics/behavior/flows/sankey"},next:{title:"Sunburst",permalink:"/docs/metrics/behavior/flows/sunburst"}},l={},c=[{value:"Flows Tree",id:"flows-tree",level:2},{value:"Nodes",id:"nodes",level:3},{value:"Intents",id:"intents",level:4},{value:"Chatbot Actions",id:"chatbot-actions",level:4},{value:"Events/Composite Events",id:"eventscomposite-events",level:4},{value:"Fallback",id:"fallback",level:4},{value:"Exit (User Leaves Conversation)",id:"exit-user-leaves-conversation",level:4},{value:"Escalation",id:"escalation",level:4},{value:"Built-In Events",id:"built-in-events",level:4},{value:"Tree Structure",id:"tree-structure",level:3},{value:"Branches and Sub-Branches",id:"branches-and-sub-branches",level:3},{value:"Colors and Labels",id:"colors-and-labels",level:3},{value:"Interpreting a Flows Tree Graph for a Chatbot",id:"interpreting-a-flows-tree-graph-for-a-chatbot",level:3},{value:"Conversation Structure",id:"conversation-structure",level:4},{value:"Fallback and Escalation Paths",id:"fallback-and-escalation-paths",level:4},{value:"Exit Points Analysis",id:"exit-points-analysis",level:4},{value:"Event-Driven Behavior",id:"event-driven-behavior",level:4},{value:"Use Cases for Flows Tree Graph Analysis",id:"use-cases-for-flows-tree-graph-analysis",level:3},{value:"Chatbot Conversation Design",id:"chatbot-conversation-design",level:4},{value:"Exit Point Optimization",id:"exit-point-optimization",level:4},{value:"User Experience Enhancement",id:"user-experience-enhancement",level:4},{value:"Training and Development",id:"training-and-development",level:4}];function h(e){const t={h2:"h2",h3:"h3",h4:"h4",p:"p",...(0,i.ah)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.h2,{id:"flows-tree",children:"Flows Tree"}),"\n",(0,s.jsx)(t.p,{children:"A flows tree graph for a chatbot, with nodes representing intents, chatbot actions, events/composite events, fallback, exit (when users leave the conversation due to non-completed tasks), escalation, and built-in events, is a visual representation that illustrates the flow of interactions within a chatbot's conversation space in a hierarchical tree-like structure. Unlike a Sankey graph that shows transitions between nodes, a tree graph focuses on displaying the chatbot's conversation structure, making it easier to understand the hierarchy of intents, actions, and events."}),"\n",(0,s.jsx)(t.p,{children:"Here's how to interpret and understand this tree graph"}),"\n",(0,s.jsx)(t.h3,{id:"nodes",children:"Nodes"}),"\n",(0,s.jsx)(t.h4,{id:"intents",children:"Intents"}),"\n",(0,s.jsx)(t.p,{children:'Intents represent the user\'s purpose or goal behind their input. Each intent reflects a specific user request or inquiry, such as "Book a Flight," "Check Account Balance," or "Order Pizza."'}),"\n",(0,s.jsx)(t.h4,{id:"chatbot-actions",children:"Chatbot Actions"}),"\n",(0,s.jsx)(t.p,{children:'Chatbot actions are the specific tasks or operations that the chatbot performs to fulfill user requests. These actions include actions like "Retrieve Flight Options," "Process Payment," or "Retrieve Weather Information."'}),"\n",(0,s.jsx)(t.h4,{id:"eventscomposite-events",children:"Events/Composite Events"}),"\n",(0,s.jsx)(t.p,{children:'Events represent specific triggers or occurrences within the conversation that may lead to particular actions or transitions. Events can include user expressions and other contextual cues. For instance, "User Asks for Help," "User Expresses Frustration,".'}),"\n",(0,s.jsx)(t.p,{children:'Composite events are combinations of intents, events, and built-in events that represent complex user input or scenarios. These events may be part of a sentence or composition of other intents, events, and built-in events. For example, "Change Flight Date" could be a composite event comprising the intent "Modify Booking," the event "Change Date," and a built-in event like "Message Delivered."'}),"\n",(0,s.jsx)(t.h4,{id:"fallback",children:"Fallback"}),"\n",(0,s.jsx)(t.p,{children:"Fallback represents a state where the chatbot is unable to understand or determine the user's intent from their input. It typically triggers a default or general response seeking clarification or providing assistance."}),"\n",(0,s.jsx)(t.h4,{id:"exit-user-leaves-conversation",children:"Exit (User Leaves Conversation)"}),"\n",(0,s.jsx)(t.p,{children:"Exit represents a point in the conversation where the user decides to leave the interaction due to non-completed tasks or other reasons. It indicates the end of the conversation without resolution."}),"\n",(0,s.jsx)(t.h4,{id:"escalation",children:"Escalation"}),"\n",(0,s.jsx)(t.p,{children:"Escalation represents a transition where the conversation is passed on or escalated to a human agent or a higher level of support due to complexity, user request, or other specific criteria."}),"\n",(0,s.jsx)(t.h4,{id:"built-in-events",children:"Built-In Events"}),"\n",(0,s.jsx)(t.p,{children:'Built-in events are system-generated events that are not directly initiated by the user but are part of the chatbot platform\'s functioning. Examples include "Message Delivered" (indicating the delivery of a chat message) and "Message Read" (indicating that the user has read a message).'}),"\n",(0,s.jsx)(t.h3,{id:"tree-structure",children:"Tree Structure"}),"\n",(0,s.jsx)(t.p,{children:"In the tree graph, nodes are organized hierarchically, with intents, actions, events, composite events, and built-in events forming branches and sub-branches of the conversation tree."}),"\n",(0,s.jsx)(t.h3,{id:"branches-and-sub-branches",children:"Branches and Sub-Branches"}),"\n",(0,s.jsx)(t.p,{children:"The graph visually shows how different intents, actions, events, and other nodes are connected and organized within the conversation flow. Each branch represents a specific user interaction path."}),"\n",(0,s.jsx)(t.h3,{id:"colors-and-labels",children:"Colors and Labels"}),"\n",(0,s.jsx)(t.p,{children:"Colors and labels can be used to differentiate between the different types of nodes (intents, chatbot actions, composite events, events, built-in events, fallback, exit, escalation) and help in understanding the graph more easily."}),"\n",(0,s.jsx)(t.h3,{id:"interpreting-a-flows-tree-graph-for-a-chatbot",children:"Interpreting a Flows Tree Graph for a Chatbot"}),"\n",(0,s.jsx)(t.h4,{id:"conversation-structure",children:"Conversation Structure"}),"\n",(0,s.jsx)(t.p,{children:"The tree graph offers a clear view of the hierarchy and structure of the chatbot's conversation. It shows how different intents, actions, and events are organized within the conversation flow."}),"\n",(0,s.jsx)(t.h4,{id:"fallback-and-escalation-paths",children:"Fallback and Escalation Paths"}),"\n",(0,s.jsx)(t.p,{children:"The tree graph highlights the paths that lead to fallback responses and escalation to human agents, providing insights into the chatbot's response strategies."}),"\n",(0,s.jsx)(t.h4,{id:"exit-points-analysis",children:"Exit Points Analysis"}),"\n",(0,s.jsx)(t.p,{children:"It helps in identifying where users commonly leave the conversation due to non-completed tasks or other reasons. This information is valuable for improving user engagement and task completion."}),"\n",(0,s.jsx)(t.h4,{id:"event-driven-behavior",children:"Event-Driven Behavior"}),"\n",(0,s.jsx)(t.p,{children:"The graph also indicates how different events, including user-generated and system events, influence the flow of the conversation and trigger specific actions."}),"\n",(0,s.jsx)(t.h3,{id:"use-cases-for-flows-tree-graph-analysis",children:"Use Cases for Flows Tree Graph Analysis"}),"\n",(0,s.jsx)(t.h4,{id:"chatbot-conversation-design",children:"Chatbot Conversation Design"}),"\n",(0,s.jsx)(t.p,{children:"Developers and designers can use the tree graph to visualize and refine the chatbot's conversation structure, making it more intuitive and user-friendly."}),"\n",(0,s.jsx)(t.h4,{id:"exit-point-optimization",children:"Exit Point Optimization"}),"\n",(0,s.jsx)(t.p,{children:"Analysis of exit nodes helps in identifying reasons why users leave the conversation and allows for improvements to enhance user engagement and task completion."}),"\n",(0,s.jsx)(t.h4,{id:"user-experience-enhancement",children:"User Experience Enhancement"}),"\n",(0,s.jsx)(t.p,{children:"Insights from the graph help in optimizing the user experience by addressing issues related to conversation flow and engagement."}),"\n",(0,s.jsx)(t.h4,{id:"training-and-development",children:"Training and Development"}),"\n",(0,s.jsx)(t.p,{children:"Developers can use this analysis to train the chatbot to handle various conversation paths and events more effectively."}),"\n",(0,s.jsx)(t.p,{children:"In summary, a flows tree graph for a chatbot, considering nodes as intents, chatbot actions, events/composite events, fallback, exit (user leaves conversation due to non-completed tasks), escalation, and built-in events, provides a visual representation of the chatbot's conversation structure and flow. It helps in understanding how different nodes are connected and organized within the chatbot's"})]})}function d(e={}){const{wrapper:t}={...(0,i.ah)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},3905:(e,t,n)=>{n.d(t,{ah:()=>c});var s=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);t&&(s=s.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,s)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,s,i=function(e,t){if(null==e)return{};var n,s,i={},r=Object.keys(e);for(s=0;s<r.length;s++)n=r[s],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(s=0;s<r.length;s++)n=r[s],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=s.createContext({}),c=function(e){var t=s.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},h={inlineCode:"code",wrapper:function(e){var t=e.children;return s.createElement(s.Fragment,{},t)}},d=s.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),u=c(n),p=i,v=u["".concat(l,".").concat(p)]||u[p]||h[p]||r;return n?s.createElement(v,a(a({ref:t},d),{},{components:n})):s.createElement(v,a({ref:t},d))}));d.displayName="MDXCreateElement"}}]);